// http://www.cs.man.ac.uk/~toby/alan/software/gpc.html



 //PolyDefault  is a default  Poly  implementation. 
 
 // It provides support for both complex and simple polygons. 
 
 //complex polygon:    polygon that consists of more than one polygon.  



 //simple polygon:  contains  ONE  inner polygon (a  cl of pts )
 //CANT BE A HOLE
 
 // Subject and clip polygons may be convex or concave, self-intersecting,
 // contain holes, or be comprised of several disjoint contours

//output may take the form of polygon outlines or tristrips.


//A generic polygon (or `polygon set') consists of zero or more disjoint boundaries 
// of arbitrary configuration. Each boundary is termed a `contour', and may be convex, concave or self-intersecting. 
// Internal holes may be formed by contour nesting.


/*

 The clipper takes a pair of subject and clip polygons and combines them to form a result polygon.
 
  For each contour polygon 
 in the result polygon, the hole value flags whether or not the given contour forms a hole or an external boundary.

 Alternatively
  a collection of tristrips may be generated as the result,
   this form being more suitable for rendering filled shapes.
   
  (The polygon result form is better for drawing outlines,
   or as intermediate values in multi-clip operations.)
    

 A contour is classified as an external contour
        if its uppermost (or rightmost, when the contour top is horizontal) vertex 
  forms an external local maximum (EMX).
  
   If this vertex forms an internal local maximum (IMX)
    the contour is classified as a hole contour.
    
 When contour edges cross (in self intersecting shapes for example)
  the clipper will always generate a local maximum vertex
  below the intersection (or when one of the edges is horizontal, 
   to the left of the intersection) which connects the two edge parts
   which  meet at the intersection point from below or from the left. 
   The edge parts which emerge from the opposite side
    of the intersection point originate from a new local minimum vertex.
     The closed contours generated by the clipper w 
     
 These rules have implications with regard to how self intersecting shapes decompose into a set of closed, 
 non-intersecting contours. 
 
  
 similar self intersecting shapes may each
  create two external contours which touch at the points of intersection.
  
   In summary,
   the contour paths generated by the clipper are affected not only by the shape of the input polygons, 
   but also by their orientation.

 Associating holes with external contours

 The current version of the clipper merely flags which contours are considered to be holes,
  and which form external boundaries. Discovering which holes lie within which external contours 
  takes a little more work on the part of the user. 
  One way to associate holes H1, H2 ... Hn with external contours E1, E2 ... Em is to use the clipper
   to compute the difference of the ith hole Hi and each external contour Ej,
    for all j from 1 to m. Any difference which gives an empty result indicates that 
    hole i lies within external contour j.
 Coincident and near-coincident edges

 The clipper will merge edges which are coincident.
  Adjacent subject and clip contours which share share a common edge
   will fuse to form a single contour under the union operation, 
   and will produce a null result along their shared boundary under the intersection operation.
     Numerical precision limits are likely to cause the slight misregistration
      of coincident edges,
       resulting in a failure to merge. 
       Increasing the value of the GPC_EPSILON constant in gpc.h 
       will encourage the merging of near-coincident edges. However, incorrect output polygon shapes
        may result if GPC_EPSILON is given too large a value.

 */
 
function addPoint(){
 //If a point is added to an empty  PolyDefault 
 // object, it will create an inner polygon of type PolySimple
 //
 // 
 // //
 // 
 // 
 //    Add a point to the first inner polygon.
 // If a point is added to an empty PolyDefault object,
 //    it will create an inner polygon of type  PolySimple
 //addPointXY(x:Number, y:Number):void {     addPoint( new Point( x, y ) );  }
 // 
 // 
 // 
 // 
 // 
 // // 
 //   
 //    Add a point to the first inner polygon.
 //     If a point is added to an empty PolyDefault object,
 //    it will create an inner polygon of type  PolySimple .
 // addPoint( p:Point):void {
 //     if( m_List.size() == 0) {  m_List.add( new PolySimple() );      }
 //     (Poly(m_List.get(0))).addPoint( p );
 //  }
 //  
	}

	
	
function addPol(){
 
 
 //    ***Add an inner polygon to this polygon - assumes that adding polygon does not  have any inner polygons.  
 //    @throws IllegalStateException if the number of inner polygons is greater than
 //    zero and this polygon was designated a hole.  This would break the assumption
 //    that only simple polygons can be holes.
 
 //     addPoly( p:Poly):void {      if( (m_List.size() > 0) && m_IsHole )      { throw new Error("Cannot add polys to something designated as a hole.")     }
 //     m_List.add( p );
 //  }
 //  
}

function empty(){
 //    Return true if the polygon is empty public function isEmpty():Boolean { return m_List.isEmpty(); }
}

function boundRec(){
 //    Returns the bounding rectangle of this polygon.
 //   ---Not supported on complex polygons.  
 //getBounds():Rectangle {
 //     if( m_List.size() == 0)      {         return new Rectangle();  }
 //     else if( m_List.size() == 1)      {         var ip:Poly= getInnerPoly(0);         return ip.getBounds(); }
 //     else      {         throw new Error("getBounds not supported on complex poly.");      }
 //  }
 //  
 // 
	}
	
	
 
 
 //   getInnerPoly(polyIndex:int):Poly { return m_List.get(polyIndex) as Poly; } //    Returns the polygon at this index.
 
 
 
 function num(){
 //    Returns the number of inner polygons - inner polygons are assumed to return one here.
 //    
 //   
 //   
 //    getNumInnerPoly():int {   return m_List.size();   }
 //  
 //   
 //    Return the number points of the first inner polygon
 //    
 //  getNumPoints():int {      return (Poly(m_List.get(0))).getNumPoints() ;   }
 //  
 
	 }
 
 
 
 function xyVals(){
 //    Return the X value of the point at the index in the first inner polygon
 //    
 //
 //getX(index:int):Number {      return (Poly(m_List.get(0))).getX(index) ;  }
	 //    Return the Y value of the point at the index in the first inner polygon
	 //    
	 //  public function getY(index:int):Number {
	 //     return (Poly(m_List.get(0))).getY(index) ;
	 //  }
	 //  
 }
 
 function getPtorPts(){
 //getPoint(index:int):Point{		return (Poly(m_List.get(0))).getPoint(index) ; }
 
 //  getPoints():Array{ return (Poly(m_List.get(0))).getPoints();  }
 //  
 //  
 //  
 //  public function isPointInside(point:Point):Boolean{
 //  		if (!(Poly(m_List.get(0))).isPointInside(point)) return false;
 //  		for (var i : int = 0; i<m_List.size(); i++){
 //  			var poly : Poly = m_List.get(i) as Poly;
 //  			if ((poly.isHole())&&(poly.isPointInside(point))) return false;
 //  		}
 //  		return true;
 //  }
 //  
 }  
 
 

 
 function hole(){
 //    Return true if this polygon is a hole.  Holes are assumed to be inner polygons of
 //    a more complex polygon.
 //   
 //    @throws IllegalStateException if called on a complex polygon.
 //    
 //  public function isHole():Boolean {
 //     if( m_List.size() > 1)
 //     {
 //        throw new Error( "Cannot call on a poly made up of more than one poly." );
 //     }
 //     return m_IsHole ;
 //  }
 //  
 //   
 //    Set whether or not this polygon is a hole.  Cannot be called on a complex polygon.
 //   
 //    @throws IllegalStateException if called on a complex polygon.
 //    
 //  public function setIsHole( isHole:Boolean):void {
 //     if( m_List.size() > 1)
 //     {
 //        throw new Error( "Cannot call on a poly made up of more than one poly." );
 //     }
 //     m_IsHole = isHole ;
 //  }
 //  
 //   

 }
 
 
 
 function contrib(){
	
	 //    Return true if the given inner polygon is contributing to the set operation.
	 //    This method should NOT be used outside the Clip algorithm.
	 //    
	 //  public function isContributing( polyIndex:int):Boolean {
	 //     return (Poly(m_List.get(polyIndex))).isContributing(0);
	 //  }
	 //  
 
 //    Set whether or not this inner polygon is constributing to the set operation.
 //    This method should NOT be used outside the Clip algorithm.
 //   
 //    @throws IllegalStateException if called on a complex polygon
 //    
 //  public function setContributing( polyIndex:int, contributes:Boolean):void {
 //     if( m_List.size() != 1)
 //     {
 //        throw new Error( "Only applies to polys of size 1" );
 //     }
 //     (Poly(m_List.get(polyIndex))).setContributing( 0, contributes );
 //  }
 //  
 }
 
 
 function isx(){
 //    Return a Poly that is the intersection of this polygon with the given polygon.
 //    The returned polygon could be complex.
 //   
 //    @return the returned Poly will be an instance of PolyDefault.
 //    
 //  public function intersection(p:Poly):Poly {
 //     return Clip.intersection( p, this, "PolyDefault");
 //  }
 //  
 //   
 //    Return a Poly that is the union of this polygon with the given polygon.
 //    The returned polygon could be complex.
 //   
 //    @return the returned Poly will be an instance of PolyDefault.
 //    
 //  public function union(p:Poly):Poly {
 //     return Clip.union( p, this, "PolyDefault");
 //  }
 //  
	 }
 function xor(){   
 //    Return a Poly that is the exclusive-or of this polygon with the given polygon.
 //    The returned polygon could be complex.
 //   
 //    @return the returned Poly will be an instance of PolyDefault.
 //    
 //  public function xor(p:Poly):Poly {
 //     return Clip.xor( p, this, "PolyDefault" );
 //  }
 //  
 //   
	// Return a Poly that is the difference of this polygon with the given polygon.
	// The returned polygon could be complex.
	//
	// @return the returned Poly will be an instance of PolyDefault.
	// 
 //  public function difference(p:Poly):Poly{
	//   return Clip.difference(p,this,"PolyDefault");
 //  }
 //  
 }
 function area(){
 //    Return the area of the polygon in square units.
 //    
 //  public function getArea():Number {
 //     var area:Number= 0.0;
 //     for( var i:int= 0; i < getNumInnerPoly() ; i++ )
 //     {
 //        var p:Poly= getInnerPoly(i);
 //        var tarea:Number= p.getArea()  (p.isHole() ? -1.0: 1.0);
 //        area += tarea ;
 //     }
 //     return area ;
 //  }
	 }
 
 
 function polySimp(){
	// 
	// /*
	//
	//
	//
	//  /**
	//  * <code>PolySimple</code> is a simple polygon - contains only one inner polygon.
	//  * <p>
	//  * <strong>WARNING:</strong> This type of <code>Poly</code> cannot be used for an
	//  * inner polygon that is a hole.
 	//  
 
	//		 protected
	//		 var m_List:List = new ArrayList();
	//		 /** Flag used by the Clip algorithm */
	//		 private var m_Contributes:Boolean = true;
	//		 // --------------------
	//		 // --- Constructors ---
	//		 // --------------------
	//		 /** Creates a new instance of PolySimple */
	//		 public function PolySimple() {
	//		 }
	//		
	//		 // ----------------------
	//		 // --- Object Methods ---
	//		 // ----------------------
	//		 /**
	//		  * Return true if the given object is equal to this one.
	//		  * <p>
	//		  * <strong>WARNING:</strong> This method failse if the first point
	//		  * appears more than once in the list.
	//		  */
	//		 public function equals(obj:Object):Boolean {
	//			 if (!(obj is
	//			 PolySimple
	//		 ) )
	//			 {
	//				 return false;
	//			 }
	//			 var that:PolySimple = PolySimple(obj);
	//			 var this_num:int = this.m_List.size();
	//			 var that_num:int = that.m_List.size();
	//			 if (this_num != that_num) return false;
	//			 // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//			 // !!! WARNING: This is not the greatest algorithm.  It fails if !!!
	//			 // !!! the first point in "this" poly appears more than once.    !!!
	//			 // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//			 if (this_num > 0) {
	//				 var this_x:Number = this.getX(0);
	//				 var this_y:Number = this.getY(0);
	//				 var that_first_index:int = -1;
	//				 for (var that_index:int = 0; (that_first_index == -1) && (that_index < that_num); that_index++) {
	//					 var that_x:Number = that.getX(that_index);
	//					 var that_y:Number = that.getY(that_index);
	//					 if ((this_x == that_x) && (this_y == that_y)) {
	//						 that_first_index = that_index;
	//					 }
	//				 }
	//				 if (that_first_index == -1) return false;
	//				 var that_index:int = that_first_index;
	//				 for (var this_index:int = 0; this_index < this_num; this_index++) {
	//					 this_x = this.getX(this_index);
	//					 this_y = this.getY(this_index);
	//					 var that_x:Number = that.getX(that_index);
	//					 var that_y:Number = that.getY(that_index);
	//					 if ((this_x != that_x) || (this_y != that_y)) return false;
	//					 that_index++;
	//					 if (that_index >= that_num) {
	//						 that_index = 0;
	//					 }
	//				 }
	//			 }
	//			 return true;
	//		 }
	//		
	//		 /**
	//		  * Return the hashCode of the object.
	//		  * <p>
	//		  * <strong>WARNING:</strong>Hash and Equals break contract.
	//		  *
	//		  * @return an integer value that is the same for two objects
	//		  * whenever their internal representation is the same (equals() is true)
	//		  */
	//		 public function hashCode():int {
	//			 // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//			 // !!! WARNING:  This hash and equals break the contract. !!!
	//			 // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//			 var result:int = 17;
	//			 result = 37 * result + m_List.hashCode();
	//			 return result;
	//		 }
	//		
	//		 /**
	//		  * Return a string briefly describing the polygon.
	//		  */
	//		 public function toString():String {
	//			 return "PolySimple: num_points=" + getNumPoints();
	//		 }
	//		
	//		 // --------------------
	//		 // --- Poly Methods ---
	//		 // --------------------
	//		 /**
	//		  * Remove all of the points.  Creates an empty polygon.
	//		  */
	//		 public function clear():void {
	//			 m_List.clear();
	//		 }
	//		
	//		 public function add(
	//	
	//	 ...
	//		 args
	//	 ):
	//				 void {
	//		 if(args
	//	
	//	 .
	//		 length
	//	 ==2) {
	//		 addPointXY(args
	//	
	//	 [0] as
	//		 Number, args
	//	 [1] as
	//		 Number
	//	 )
	//		 ;
	//	 }
	// else
	//	 if (args.length == 1) {
	//		 if (args[0] is
	//		 Point
	//	 )
	//		 {
	//			 addPoint(args[0] as Point);
	//		 }
	//	 else
	//		 if (args[0] is
	//		 Poly
	//	 )
	//		 {
	//			 addPoly(args[0] as Poly);
	//		 }
	//	 else
	//		 if (args[0] is
	//		 Array
	//	 )
	//		 {
	//			 for each(var val
	//		 :
	//			 Object in args[0] as Array
	//		 )
	//			 {
	//				 add(val);
	//			 }
	//		 }
	//	 }
	// }
 ///**
 // * Add a point to the first inner polygon.
 // */
 //public
 //function addPointXY(x
 //:
 //Number, y
 //:
 //Number
 //):
 //void {
	// addPoint( new Point(x, y) );
 //}
 ///**
 // * Add a point to the first inner polygon.
 // */
 //public
 //function addPoint(p
 //:
 //Point
 //):
 //void {
	// m_List.add(p);
 //}
 ///**
 // * Throws IllegalStateexception if called
 // */
 //public
 //function addPoly(p
 //:
 //Poly
 //):
 //void {
	// throw new Error("Cannot add poly to a simple poly.");
 //}
 ///**
 // * Return true if the polygon is empty
 // */
 //public
 //function isEmpty()
 //:
 //Boolean
 //{
	// return m_List.isEmpty();
 //}
 ///**
 // * Returns the bounding rectangle of this polygon.
 // */
 //public
 //function getBounds()
 //:
 //Rectangle
 //{
	// var xmin
 //:
	// Number = Number.MAX_VALUE;
	// var ymin
 //:
	// Number = Number.MAX_VALUE;
	// var xmax
 //:
	// Number = -Number.MAX_VALUE;
	// var ymax
 //:
	// Number = -Number.MAX_VALUE;
	// for (var i:
	// int = 0;
	// i < m_List.size();
	// i++
 //)
	// {
	//	 var x
	// :
	//	 Number = getX(i);
	//	 var y
	// :
	//	 Number = getY(i);
	//	 if (x < xmin) xmin = x;
	//	 if (x > xmax) xmax = x;
	//	 if (y < ymin) ymin = y;
	//	 if (y > ymax) ymax = y;
	// }
	// return new Rectangle(xmin, ymin, (xmax - xmin), (ymax - ymin));
 //}
 ///**
 // * Returns <code>this</code> if <code>polyIndex = 0</code>, else it throws
 // * IllegalStateException.
 // */
 //public
 //function getInnerPoly(polyIndex
 //:
 //int
 //):
 //Poly
 //{
	// if (polyIndex != 0) {
	//	 throw new Error("PolySimple only has one poly");
	// }
	// return this;
 //}
 ///**
 // * Always returns 1.
 // */
 //public
 //function getNumInnerPoly()
 //:
 //int
 //{
	// return 1;
 //}
 ///**
 // * Return the number points of the first inner polygon
 // */
 //public
 //function getNumPoints()
 //:
 //int
 //{
	// return m_List.size();
 //}
 ///**
 // * Return the X value of the point at the index in the first inner polygon
 // */
 //public
 //function getX(index
 //:
 //int
 //):
 //Number
 //{
	// return (Point(m_List.get(index))).x;
 //}
 ///**
 // * Return the Y value of the point at the index in the first inner polygon
 // */
 //public
 //function getY(index
 //:
 //int
 //):
 //Number
 //{
	// return (Point(m_List.get(index))).y;
 //}
 //public
 //function getPoint(index
 //:
 //int
 //):
 //Point
 //{
	// return (Point(m_List.get(index)));
 //}
 //public
 //function getPoints()
 //:
 //Array
 //{
	// return m_List.toArray();
 //}
 //public
 //function isPointInside(point
 //:
 //Point
 //):
 //Boolean
 //{
	// var points
 //:
	// Array = getPoints();
	// var j
 //:
	// int = points.length - 1;
	// var oddNodes
 //:
	// Boolean = false;
	// for (var i :
	// int = 0;
	// i < points.length;
	// i++
 //)
	// {
	//	 if (points[i].y < point.y && points[j].y >= point.y ||
	//			 points[j].y < point.y && points[i].y >= point.y) {
	//		 if (points[i].x +
	//				 (point.y - points[i].y) / (points[j].y - points[i].y) * (points[j].x - points[i].x) < point.x) {
	//			 oddNodes = !oddNodes;
	//		 }
	//	 }
	//	 j = i;
	// }
	// return oddNodes;
 //}
 ///**
 // * Always returns false since PolySimples cannot be holes.
 // */
 //public
 //function isHole()
 //:
 //Boolean
 //{
	// return false;
 //}
 ///**
 // * Throws IllegalStateException if called.
 // */
 //public
 //function setIsHole(isHole
 //:
 //Boolean
 //):
 //void {
	// throw new Error("PolySimple cannot be a hole");
 //}
 ///**
 // * Return true if the given inner polygon is contributing to the set operation.
 // * This method should NOT be used outside the Clip algorithm.
 // *
 // * @throws IllegalStateException if <code>polyIndex != 0</code>
 // */
 //public
 //function isContributing(polyIndex
 //:
 //int
 //):
 //Boolean
 //{
	// if (polyIndex != 0) {
	//	 throw new Error("PolySimple only has one poly");
	// }
	// return m_Contributes;
 //}
 ///**
 // * Set whether or not this inner polygon is constributing to the set operation.
 // * This method should NOT be used outside the Clip algorithm.
 // *
 // * @throws IllegalStateException if <code>polyIndex != 0</code>
 // */
 //public
 //function setContributing(polyIndex
 //:
 //int, contributes
 //:
 //Boolean
 //):
 //void {
	// if( polyIndex != 0)
 //{
	// throw new Error("PolySimple only has one poly");
 //}
 //m_Contributes = contributes;
 //}
  
  function isx(){
 // * Return a Poly that is the intersection of this polygon with the given polygon.
 // * The returned polygon is simple.
 // *
 // * @return The returned Poly is of type PolySimple
 // */
 //public
 //function intersection(p
 //:
 //Poly
 //):
 //Poly
 //{
	// return Clip.intersection(this, p, "PolySimple");
 //}
 
  }
 
 ///**
 // * Return a Poly that is the union of this polygon with the given polygon.
 // * The returned polygon is simple.
 // *
 // * @return The returned Poly is of type PolySimple
 // */
 //public
 //function union(p
 //:
 //Poly
 //):
 //Poly
 //{
	// return Clip.union(this, p, "PolySimple");
 //}

 function xor(){
	
	 ///**
	 // * Return a Poly that is the exclusive-or of this polygon with the given polygon.
	 // * The returned polygon is simple.
	 // *
	 // * @return The returned Poly is of type PolySimple
	 // */
	 //public
	 //function xor(p
 //:
 //Poly
 //):
 //Poly
 //{
	// return Clip.xor(p, this, "PolySimple");
 //}

 }
 
 function diff(){
	
	
	 ///**
	 // * Return a Poly that is the difference of this polygon with the given polygon.
	 // * The returned polygon could be complex.
	 // *
	 // * @return the returned Poly will be an instance of PolyDefault.
	 // */
 
 
 //public
 //function difference(p
 //:
 //Poly
 //):
 //Poly
 //{
	// return Clip.difference(p, this, "PolySimple");
 //}
	 }
 ///**
 // * Returns the area of the polygon.
 // * <p>
 // * The algorithm for the area of a complex polygon was take from
 // * code by Joseph O'Rourke author of " Computational Geometry in C".
 // */
 //public
 //function getArea()
 //:
 //Number
 //{
	// if (getNumPoints() < 3) {
	//	 return 0.0;
	// }
	// var ax
 //:
	// Number = getX(0);
	// var ay
 //:
	// Number = getY(0);
	// var area
 //:
	// Number = 0.0;
	// for (var i:
	// int = 1;
	// i < (getNumPoints() - 1);
	// i++
 //)
	// {
	//	 var bx
	// :
	//	 Number = getX(i);
	//	 var by
	// :
	//	 Number = getY(i);
	//	 var cx
	// :
	//	 Number = getX(i + 1);
	//	 var cy
	// :
	//	 Number = getY(i + 1);
	//	 var tarea
	// :
	//	 Number = ((cx - bx) * (ay - by)) - ((ax - bx) * (cy - by));
	//	 area += tarea;
	// }
	// area = 0.5 * Math.abs(area);
	// return area;
 //}
//	  */
	 
	 
	 }